<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python中将字符串变成作为变量名的方法]]></title>
    <url>%2F2018%2F08%2F01%2Fpython%E4%B8%AD%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%88%90%E4%BD%9C%E4%B8%BA%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用exec函数python 3：exec 被当成一个函数 ，可以通过以下的方法来进行将字符串变成变量的名字进行赋值 12x = 'buf'exec("%s = %d" % (x, 2)) 1234&gt;&gt;&gt; foo = "bar"&gt;&gt;&gt; exec(foo + " = 'something else'")&gt;&gt;&gt; print barsomething else python 2:exec 是一个语句， 只能使用下面的方法： 12x='buffalo'exec "%s = %d" % (x,2) 使用locals()1234567891011&gt;&gt;&gt; var = "This is a string" &gt;&gt;&gt; varName = 'var' &gt;&gt;&gt; s= locals()[varName] &gt;&gt;&gt; s 'This is a string' &gt;&gt;&gt; s2=vars()[varName] &gt;&gt;&gt; s2 'This is a string' &gt;&gt;&gt; s3=eval(varName) &gt;&gt;&gt; s3 'This is a string' locals是python的内置函数，他可以以字典的方式去访问局部和全局变量。 python里面用名字空间记录着变量，就像javascript的window一样，他记录着各种全局变量。 每个模块，每个函数都有自己的名字空间，记录着变量，常量，类的命名和值。 就像JS一样，当python在使用变量时，会按照下面的步骤去搜索： 函数或类的局部变量。 全局变量。 内置变量。 以上三个步骤，其中一步骤找到对应的变量，就不会再往下找。如果在这三个步骤都找不到，就会抛出异常。 locals与globals的区别 locals()是只读的。globals()不是。这里说的只读，是值对于原有变量的只读。其实还可以对locals()赋值的。 globals返回的是当前模块的全局变量 locals返回的是局部变量。注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。 体验locals 1234567891011list1 = [1,2,3]locals()# 在全局中使用locals，会打印出list1和__builtins__、__name__、__doc__、__package__ def foo(args): x=1 print locals()foo(123)#将会得到 &#123;'args':123,'x':1&#125; 使用vars()本函数是实现返回对象object的属性和属性值的字典对象。如果默认不输入参数，就打印当前调用位置的属性和属性值，相当于locals()的功能。如果有参数输入，就只打印这个参数相应的属性和属性值。 12345678910#vars()print(vars())class Foo: a = 1print(vars(Foo))foo = Foo()print(vars(foo)) 使用eval()函数eval()函数十分强大，官方demo解释为：将字符串str当成有效的表达式来求值并返回计算结果。结合math当成一个计算器很好用。其他用法，可以把list,tuple,dict和string相互转化。见下例子： 12345678910111213141516a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"b = eval(a)bOut[3]: [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]type(b)Out[4]: lista = "&#123;1: 'a', 2: 'b'&#125;"b = eval(a)bOut[7]: &#123;1: 'a', 2: 'b'&#125;type(b)Out[8]: dicta = "([1,2], [3,4], [5,6], [7,8], (9,0))"b = eval(a)bOut[11]: ([1, 2], [3, 4], [5, 6], [7, 8], (9, 0)) 强大的函数有代价。安全性是其最大的缺点。 想一想这种使用环境：需要用户输入一个表达式，并求值。 如果用户恶意输入，例如： import(‘os’).system(‘dir’) 那么eval()之后，你会发现，当前目录文件都会展现在用户前面。 那么继续输入： open(‘文件名’).read() 代码都给人看了。获取完毕，一条删除命令，文件消失。哭吧！ 使用hasattr()、setattr()和delattr()参考链接[1] https://www.cnblogs.com/hwy89289709/p/6934822.html[2] https://blog.csdn.net/rentian1/article/details/79437863]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>变量命名</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python用字符串导入库和函数]]></title>
    <url>%2F2018%2F08%2F01%2Fpython%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%BC%E5%85%A5%E5%BA%93%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用import()函数导入12345inp=input('moudulus: ')d= __import__(inp)inp_func=input('func name: ')tfun=getattr(inp,inp_func)tfun() hasattr(modulus,funcname)模块中有没有这个函数 setattr(modulus,funname,lambda )创建全局变量或者函数 delattr(modulus,funcname)删除 参考链接[1] https://www.cnblogs.com/ezway/p/6609544.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>导入库</tag>
        <tag>导入函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构绪论]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[1. 基本概念和术语数据 数据:&emsp;是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合具备如下特征： 可以输入到计算机中 能被计算机程序处理 数据可分为两类： 数值类型&emsp;整型、实型等，可以进行数值计算 字符类型&emsp;进行非数值的处理。而声音、图像、视频等其实是可以编码成字符数据来处理的 2. 算法算法的特性算法具有5个基本特性：输入、输出、有穷性、确定性和可行性。 1.输入输出&emsp;&emsp; - 算法具有零个或多个输入&emsp;&emsp; - 算法至少有一个或多个输出，输出形式可以是打印输出，也可以是返回一个或多个值等，或者改变全局变量（算返回变量）2.有穷性3.确定性&emsp;&emsp; - 每一个步骤有确定的含义&emsp;&emsp; - 相同的输入获得唯一的输出结果4.可行性 算法设计的要求1.正确性2.可读性3.健壮性4.时间效率高和存储量低 3. 算法效率的度量方法如1+2+3+]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器&&描述符]]></title>
    <url>%2F2018%2F07%2F20%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%26%26%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[python装饰器12345@wrapperdef func(*args, **kwargs) pass等同于func = wrapper(func) 由上可见，作为装饰器的对象，只需要是可调用对象就行。可以是： 类对象：可以仅传入func单参数初始化 函数对象：以func作为输入值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Setter(object): def __init__(self, func): self.func = func def __set__(self, obj, value): return self.func(obj, value)#class Property(object):# def __init__(self, Get, Set, Del):# self.Get = Get# self.Set = Set# self.Del = Del## def __get__(self, obj, Type=None):# return self.Get(obj)# # def __set__(self, obj, value):# return self.Set(obj, value)# # def __delete__(self, obj):# return self.Del(obj) class Property(object): def __init__(self, Get, Set=None, Del=None): self.Get = Get self.Set = Set self.Del = Del def __get__(self, obj, Type=None): return self.Get(obj) def __set__(self, obj, value): return self.Set(obj, value) def __delete__(self, obj): return self.Del(obj) def setter(self, fn): self.Set = fn return self def deleter(self, fn): self.Del = fn return selfclass Mymath(object): def __init__(self, pi, name): self._PI = pi self.myname = name @Property def PI(self): return self._PI @PI.setter def PI(self, value): self._PI = value @PI.deleter def PI(self): del self._PI # PI = Property(Get_PI, Set_PI, Del_PI) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 下面部分实现total_ordering功能# from functools import total_orderingdef Total_ordering(cls):# for cmp in ['__lt__', '__le__', '__gt__', '__ge__', '__ne__']: cls.__le__ = lambda self, other: self &lt; other or self == other cls.__gt__ = lambda self, other: not (self &lt; other or self == other) cls.__ge__ = lambda self, other: not (self &lt; other) cls.__ne__ = lambda self, other: not self == other return cls @Total_orderingclass House(object): def __init__(self, name, width, length): self. name = name self.width = width self.length = length def __eg__(self, other): return self.width * self.length == other.width * other.length def __lt__(self, other): return self.width * self.length &lt; other.width * other.length a = House('hkf', 12, 13)b = House('myhouse', 24, 23)print(a&lt;b)函数中返回一个对象，可以是函数对象，也可以是实例对象，当然也可以是类对象，说明这里的随意性注：所有的方法调用，均为绑定，不是编译器自己将点号'.'运算符自动转换为（self, *args），就是我们可以认为转换，针对类方法，其实就是我们自己通过描述符绑定class A(object): def class_meth(cls, *args): passclass Bound(object): def __init__(self, func): self.func = func def __get__(self, obj, type=None): def _func(type, *args): return self.func(type, *args) return _func这里就使class_meth成为Bound对象，又因为Bound为描述符，因此调用时自动调用__get__，返回绑定方法绑定的都是类方法吗？ 由于对象属性自动绑定吗？静态方法因为要辨别调用是否为类或实例对象，要做判别所以也用了描述符特性 描述符协议描述符协议，表现形式就和绑定形式差不多。定义了get, set, deleter的类就成为描述符根据python解释器的解释 1234567使用描述符的类，其实就相当于在类中定义了一个描述符对象PI = Property(Get_PI, Set_PI, Del_PI)调用时，解释器将对于PI的调用进行翻译：myobj = Mymath()myobj.PI ----&gt; type(myobj).['PI'].__get__(myobj, type(myobj))Mymath.PI ----&gt; Mymath['PI'].__get__(None, Mymath)可以看出， 描述符都是在类中定义的 属性调用顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Base(object): ... def read_attr(self, fieldname): """ read field 'fieldname' out of the object """ result = self._read_dict(fieldname) if result is not MISSING: return result result = self.cls._read_from_class(fieldname) if _is_bindable(result): return _make_boundmethod(result, self) if result is not MISSING: return result meth = self.cls._read_from_class("__getattr__") if meth is not MISSING: return meth(self, fieldname) raise AttributeError(fieldname) def write_attr(self, fieldname, value): """ write field 'fieldname' into the object """ meth = self.cls._read_from_class("__setattr__") return meth(self, fieldname, value) def _read_from_class(self, methname): for cls in self.method_resolution_order(): if methname in cls._fields: return cls._fields[methname] return MISSING def _is_bindable(meth): return hasattr(meth, "__get__") def _make_boundmethod(meth, self): return meth.__get__(self, None) def method_resolution_order(self): """ compute the method resolution order of the class """ if self.base_class is None: return [self] else: return [self] + self.base_class.method_resolution_order() def issubclass(self, cls): """ is self a subclass of cls? """ return cls in self.method_resolution_order() def __init__(self, cls, fields): """ Every object has a class. """ self.cls = cls self._fields = fields def isinstance(self, cls): """ return True if the object is an instance of class cls """ return self.cls.issubclass(cls) def callmethod(self, methname, *args): """ call method 'methname' with arguments 'args' on object """ meth = self.cls._read_from_class(methname) return meth(self, *args) def _read_dict(self, fieldname): """ read an field 'fieldname' out of the object's dict """ return self._fields.get(fieldname, MISSING) def _write_dict(self, fieldname, value): """ write a field 'fieldname' into the object's dict """ self._fields[fieldname] = valueMISSING = object()class Instance(Base): """Instance of a user-defined class. """ def __init__(self, cls): assert isinstance(cls, Class) Base.__init__(self, cls, &#123;&#125;)class Class(Base): """ A User-defined class. """ def __init__(self, name, base_class, fields, metaclass): Base.__init__(self, metaclass, fields) self.name = name self.base_class = base_class# set up the base hierarchy as in Python (the ObjVLisp model)# the ultimate base class is OBJECTOBJECT = Class(name="object", base_class=None, fields=&#123;&#125;, metaclass=None)# TYPE is a subclass of OBJECTTYPE = Class(name="type", base_class=OBJECT, fields=&#123;&#125;, metaclass=None)# TYPE is an instance of itselfTYPE.cls = TYPE# OBJECT is an instance of TYPEOBJECT.cls = TYPEdef OBJECT__setattr__(self, fieldname, value): self._write_dict(fieldname, value)OBJECT = Class("object", None, &#123;"__setattr__": OBJECT__setattr__&#125;, None) 1234567891011121314151617181920212223'''由下面仿真python读取属性的方式可以看见：1、python首先在对象__dict__中查找；2、在类链中查找，是描述符则绑定后返回值；3、若不是描述符，则直接返回对象4、以上都没有发现的属性，则查看类链中是否有__getattr__属性5、有的话，返回绑定后的调用结果，既__getattr__(self, fieldname)6、返回AttributeError对象''' def read_attr(self, fieldname): """ read field 'fieldname' out of the object """ result = self._read_dict(fieldname) if result is not MISSING: return result result = self.cls._read_from_class(fieldname) if _is_bindable(result): return _make_boundmethod(result, self) if result is not MISSING: return result meth = self.cls._read_from_class("__getattr__") if meth is not MISSING: return meth(self, fieldname) raise AttributeError(fieldname) [1] http://aosabook.org/en/500L/a-simple-object-model.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
        <tag>描述符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程相关概念解惑]]></title>
    <url>%2F2018%2F07%2F20%2F%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%83%91%2F</url>
    <content type="text"><![CDATA[非计算机专业，编程缺乏练习，经常出现一些粗浅的概念，却不能明了的解释和阐明。因此在这里列一些最近感觉理解更加清晰的概念进行简要阐释，后续待进一步完善： 插件本质是什么？ 配置文件的格式选择以及作用？ 引擎指什么？ 事件驱动怎么理解？ 回调函数的概念 观察者模式 编程范式 1. 插件本质是什么简要说明&emsp;&emsp;插件其实就是函数，框架预留的事件处理函数，由配置文件构置属性列表，框架对象根据事件属性，搜索生成插件对象列表，调用相应插件函数处理相应事件。 ###举例说明&emsp;&emsp;待补充 2. 配置文件的格式选择以及作用配置文件的格式文本&emsp;&emsp;如YAML、JSON、XML等文件格式，既易于人读写，也易于机器读写。由于这些格式是通用文本标记语言，和编程语言的选择没有关系，因此常作为不同编程语言互通信息的桥梁。 配置文件的作用&emsp;&emsp;配置文件里放程序启动时需要对程序进行配置的信息，比如我们平时启动刚安装的一款软件时，会出现一些填写注册信息的控件，并询问您是否要勾选记住密码、下次自动登录等的复选框（比如QQ、微信），这些注册信息就被写进了相应程序的配置文件里，当程序下次在启动时就会自动读取配置文件，对程序进行配置，这样我们就不用每次都填写这些注册信息，程序就会自启动了。待补充。。。 3. 引擎指什么&emsp;&emsp;引擎其实就是为了实现数据和试图模板分开的一种编程方式。其主要就是作用与根据事件调用数据相应程序，生成应用所需数据，填入视图模板中预留的内容部分。待补充。。。 4. 事件驱动怎么理解&emsp;&emsp;目的是进一步降低请求与响应之间的耦合性。方式：进行了一系列的封装。]]></content>
      <categories>
        <category>编程闲谈</category>
      </categories>
      <tags>
        <tag>编程概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习态度]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%AD%A6%E4%B9%A0%E6%80%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1. 学习心态&emsp;&emsp;学习切忌浅尝辄止和贪多，学习的过程中一定要弄懂一个概念，再看新知识。或者，也可以对于需要使用的内容，先掌握个大概，先上手使用，再慢慢弄懂。很多知识都是这样需要一个时间的间隔，才能慢慢弄懂。对于工具，一定要先示例运行，多跑几次，然后再慢慢查，做笔记，拓展。这才是学工具的一个合理的路径。 对于其它概念性知识点，一定不能急，每次对于概念的新理解，都要做笔记，将内容整理成自己可以理解的内容，不能总是不整理就囫囵吞枣的接受。这样其实自己是没有进行思考和咀嚼的，这必然导致以后发现这些知识自己又不知道。其实只是当时没有完全搞懂而已。 再者，知识是有一个遗忘周期的，一定要顶起复习。]]></content>
      <categories>
        <category>学习闲谈</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo_Next初步架构资源链接]]></title>
    <url>%2F2018%2F07%2F19%2FHexo_Next%E5%88%9D%E6%AD%A5%E6%9E%B6%E6%9E%84%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[这是一篇新手上手架构自己博客的第一步，文中内容还未完全整理提取，现将博客构建主要参考链接放在该博文中。您可以通过该博文了解： 怎么从无到有建立一个属于自己的博客 怎么设置相应参数，安装相应插件，完善博客 进一步阅读的内容链接 Quick Start丢掉你的脑子，Copy is Ok!!!More info:&emsp;&emsp;&emsp;&emsp;博客搭建GitHubPages + Hexo + Hueman&emsp;&emsp;&emsp;&emsp;博客搭建GitHubPages + Hexo + Next&emsp;&emsp;&emsp;&emsp;详细配置 进一步阅读Next主题文档介绍More info: Next主题 Hexo配置文档介绍More info: Hexo框架 Hexo架构原理More info:&emsp;&emsp;&emsp;&emsp;原理浅析&emsp;&emsp;&emsp;&emsp;原理探究&emsp;&emsp;&emsp;&emsp;How work Markdown博文撰写More info:&emsp;&emsp;&emsp;&emsp;列举编辑器&emsp;&emsp;&emsp;&emsp;推荐编辑器 Git安装及使用More info:&emsp;&emsp;&emsp;&emsp;书籍ProGit&emsp;&emsp;&emsp;&emsp;博文-廖雪峰 安装、配置问题相关npm install警告More info: npm警告]]></content>
      <categories>
        <category>Hexo_Next博客架构</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试文本</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <categories>
        <category>测试文本</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
